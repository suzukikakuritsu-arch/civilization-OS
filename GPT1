"""
Stability Optimization Simulation v2.0
Fair Comparison: Standard Update vs Phi-based Damping
Reproducible & Statistically Comparable
"""

import numpy as np

print("ğŸš€ Stability Simulation Start")
print("Standard Update vs Phi-based Nonlinear Damping")

# å®šæ•°
PHI = (1 + np.sqrt(5)) / 2
YAMATO = 8 / 5

def normalize(w):
    norm = np.linalg.norm(w)
    return w / norm if norm != 0 else w

def standard_update(weights):
    noise = np.random.normal(0, 0.05, weights.shape)
    return normalize(weights + noise)

def phi_damped_update(weights, phi_ratio=PHI, yamato_ratio=YAMATO):
    noise = np.random.normal(0, 0.05, weights.shape)
    damped = weights * np.exp(-phi_ratio * noise) * yamato_ratio
    return normalize(damped)

# å†ç¾æ€§ç¢ºä¿
np.random.seed(42)

# åˆæœŸåŒ–
std_weights = normalize(np.random.randn(1000))
phi_weights = std_weights.copy()

stabilities = {"Standard": [], "Phi-Damped": []}

for _ in range(1000):
    std_weights = standard_update(std_weights)
    phi_weights = phi_damped_update(phi_weights)

    std_stability = 1 / (1 + np.var(std_weights))
    phi_stability = 1 / (1 + np.var(phi_weights))

    stabilities["Standard"].append(std_stability)
    stabilities["Phi-Damped"].append(phi_stability)

# æœ€çµ‚å¹³å‡ï¼ˆå¾ŒåŠ100ã‚¹ãƒ†ãƒƒãƒ—ï¼‰
std_final = np.mean(stabilities["Standard"][-100:])
phi_final = np.mean(stabilities["Phi-Damped"][-100:])
improvement = (phi_final - std_final) / std_final * 100

print("\nğŸ“Š Final Comparison:")
print(f"Standard Stability: {std_final:.4f}")
print(f"Phi-Damped Stability: {phi_final:.4f}")
print(f"Relative Improvement: {improvement:.2f}%")
